#!/bin/bash

# occ - OpenShift Console wrapper for oc command
# Acts as a transparent wrapper around oc, but shows relevant console URLs on stderr

# add this line to your .bashrc to enable auto-completion
# complete -F __start_oc occ

# Function to get current namespace from oc context
get_current_namespace() {
    oc config get-contexts --no-headers 2>/dev/null | grep '^\*' | awk '{print $5}' | head -1
}

# Function to get console base URL
get_console_url() {
    oc whoami --show-console 2>/dev/null
}

# Function to convert resource type to console format and check if it's cluster-scoped
convert_resource_to_console_format() {
    local resource_type="$1"
    
    # Handle core Kubernetes resources first (most common cases)
    case "$resource_type" in
        pod|pods|po)
            echo "core~v1~Pod"
            return
            ;;
        service|services|svc)
            echo "core~v1~Service"
            return
            ;;
        configmap|configmaps|cm)
            echo "core~v1~ConfigMap"
            return
            ;;
        secret|secrets)
            echo "core~v1~Secret"
            return
            ;;
        namespace|namespaces|ns)
            echo "core~v1~Namespace"
            return
            ;;
        node|nodes|no)
            echo "core~v1~Node"
            return
            ;;
        persistentvolume|persistentvolumes|pv)
            echo "core~v1~PersistentVolume"
            return
            ;;
        persistentvolumeclaim|persistentvolumeclaims|pvc)
            echo "core~v1~PersistentVolumeClaim"
            return
            ;;
        serviceaccount|serviceaccounts|sa)
            echo "core~v1~ServiceAccount"
            return
            ;;
        deployment|deployments|deploy)
            echo "apps~v1~Deployment"
            return
            ;;
        replicaset|replicasets|rs)
            echo "apps~v1~ReplicaSet"
            return
            ;;
        daemonset|daemonsets|ds)
            echo "apps~v1~DaemonSet"
            return
            ;;
        statefulset|statefulsets|sts)
            echo "apps~v1~StatefulSet"
            return
            ;;
        job|jobs)
            echo "batch~v1~Job"
            return
            ;;
        cronjob|cronjobs|cj)
            echo "batch~v1~CronJob"
            return
            ;;
        storageclass|storageclasses|sc)
            echo "storage.k8s.io~v1~StorageClass"
            return
            ;;
        ingress|ingresses|ing)
            echo "networking.k8s.io~v1~Ingress"
            return
            ;;
        networkpolicy|networkpolicies|netpol)
            echo "networking.k8s.io~v1~NetworkPolicy"
            return
            ;;
        role|roles)
            echo "rbac.authorization.k8s.io~v1~Role"
            return
            ;;
        rolebinding|rolebindings)
            echo "rbac.authorization.k8s.io~v1~RoleBinding"
            return
            ;;
        clusterrole|clusterroles)
            echo "rbac.authorization.k8s.io~v1~ClusterRole"
            return
            ;;
        clusterrolebinding|clusterrolebindings)
            echo "rbac.authorization.k8s.io~v1~ClusterRoleBinding"
            return
            ;;
        customresourcedefinition|customresourcedefinitions|crd|crds)
            echo "apiextensions.k8s.io~v1~CustomResourceDefinition"
            return
            ;;
    esac
    
    # For unknown resources, query oc api-resources to get the proper API group/version/kind
    local resource_name="$resource_type"
    
    # If resource type contains API group (e.g., operatorconditions.operators.coreos.com), extract the base name
    if [[ "$resource_type" == *"."* ]]; then
        resource_name="${resource_type%%.*}"
    fi
    
    # Try to get the API version and kind from oc api-resources
    # First try exact match with the resource name
    local api_info=$(oc api-resources --no-headers 2>/dev/null | grep -E "^${resource_name}\s" | head -1)
    
    # If no exact match, try to find by shortname or alternative name
    if [[ -z "$api_info" ]]; then
        api_info=$(oc api-resources --no-headers 2>/dev/null | grep -E "\s${resource_name}\s" | head -1)
    fi
    
    # If still no match, try plural form (add 's')
    if [[ -z "$api_info" ]]; then
        api_info=$(oc api-resources --no-headers 2>/dev/null | grep -E "^${resource_name}s\s" | head -1)
    fi
    
    if [[ -n "$api_info" ]]; then
        # Extract API group/version and kind from the output
        # First collapse multiple spaces to single spaces, then extract columns
        # Format after collapsing: NAME SHORTNAMES APIVERSION NAMESPACED KIND
        local collapsed_info=$(echo "$api_info" | sed 's/  */ /g')
        local api_group_version=$(echo "$collapsed_info" | awk '{print $3}')
        local kind=$(echo "$collapsed_info" | awk '{print $5}')
        
        if [[ -n "$api_group_version" && -n "$kind" ]]; then
            # Convert apigroup/version to apigroup~version~Kind
            local converted_api=$(echo "$api_group_version" | sed 's|/|~|g')
            echo "${converted_api}~${kind}"
            return
        fi
    fi
    
    # If conversion fails, return original
    echo "$resource_type"
}

# Function to check if a resource is namespaced
is_resource_namespaced() {
    local resource_type="$1"
    
    # Use oc explain to get the KIND, then look up the NAMESPACED field in oc api-resources
    local explain_output=$(oc explain "$resource_type" 2>/dev/null | head -10)
    local kind=$(echo "$explain_output" | grep "^KIND:" | awk '{print $2}')
    
    if [[ -n "$kind" ]]; then
        # Look up the resource by KIND in oc api-resources
        local api_info=$(oc api-resources --no-headers 2>/dev/null | grep -E "\s${kind}$" | head -1)
        
        if [[ -n "$api_info" ]]; then
            # Extract the NAMESPACED field from the output
            # The column structure varies: NAME [SHORTNAMES] APIVERSION NAMESPACED KIND
            # We need to find the column that contains "true" or "false"
            local collapsed_info=$(echo "$api_info" | sed 's/  */ /g')
            
            # Check each column to find the one with "true" or "false"
            local num_fields=$(echo "$collapsed_info" | awk '{print NF}')
            local namespaced=""
            
            for ((i=1; i<=num_fields; i++)); do
                local field=$(echo "$collapsed_info" | awk -v col=$i '{print $col}')
                if [[ "$field" == "true" || "$field" == "false" ]]; then
                    namespaced="$field"
                    break
                fi
            done
            
            if [[ "$namespaced" == "true" ]]; then
                return 0  # true - resource is namespaced
            elif [[ "$namespaced" == "false" ]]; then
                return 1  # false - resource is cluster-scoped
            fi
        fi
    fi
    
    # If we can't determine, assume namespaced (safer default)
    return 0
}


# Function to generate the best console URL for a command
generate_console_url() {
    local cmd="$1"
    shift
    local args=("$@")
    
    # Handle special cases first
    if [[ "$cmd" == "whoami" ]]; then
        # Handle 'oc whoami' - link to user preferences
        local console_base=$(get_console_url)
        if [[ -n "$console_base" ]]; then
            echo "ðŸŒ ${console_base}/user-preferences" >&2
        fi
        return
    fi
    
    if [[ "$cmd" == "help" ]]; then
        # Handle 'oc help' - link to Red Hat CLI documentation
        echo "ðŸŒ https://docs.redhat.com/en/documentation/openshift_container_platform/4.19/html-single/cli_tools/index" >&2
        return
    fi
    
    if [[ "$cmd" == "api-resources" ]]; then
        # Handle 'oc api-resources' - link to API explorer
        local console_base=$(get_console_url)
        if [[ -n "$console_base" ]]; then
            echo "ðŸŒ ${console_base}/api-explorer" >&2
        fi
        return
    fi
    
    if [[ "$cmd" == "adm" && "${args[0]}" == "top" && "${args[1]}" == "pods" ]]; then
        # Handle 'oc adm top pods' - link to monitoring dashboard
        local console_base=$(get_console_url)
        if [[ -n "$console_base" ]]; then
            local namespace=$(get_current_namespace)
            if [[ -n "$namespace" ]]; then
                echo "ðŸŒ ${console_base}/dev-monitoring/ns/$namespace?dashboard=dashboard-k8s-resources-namespace" >&2
            fi
        fi
        return
    fi
    
    # Handle 'exec' command - link to pod terminal
    if [[ "$cmd" == "exec" ]]; then
        local console_base=$(get_console_url)
        if [[ -n "$console_base" ]]; then
            local pod_name=""
            local namespace=""
            
            # Parse exec command arguments to find pod name and namespace
            local i=0
            while [[ $i -lt ${#args[@]} ]]; do
                case "${args[$i]}" in
                    -n|--namespace)
                        i=$((i + 1))
                        if [[ $i -lt ${#args[@]} ]]; then
                            namespace="${args[$i]}"
                        fi
                        ;;
                    -c|--container|-i|--stdin|-t|--tty)
                        # Skip these flags and their values (except -i and -t which are boolean)
                        if [[ "${args[$i]}" == "-c" || "${args[$i]}" == "--container" ]]; then
                            i=$((i + 1))
                        fi
                        ;;
                    --)
                        # Stop parsing after -- (command separator)
                        break
                        ;;
                    -*)
                        # Skip other flags
                        ;;
                    *)
                        # First non-flag argument should be the pod name
                        if [[ -z "$pod_name" ]]; then
                            pod_name="${args[$i]}"
                        fi
                        ;;
                esac
                i=$((i + 1))
            done
            
            # If no namespace specified, get current namespace from context
            if [[ -z "$namespace" ]]; then
                namespace=$(get_current_namespace)
            fi
            
            # Generate terminal URL if we have pod name and namespace
            if [[ -n "$pod_name" && -n "$namespace" ]]; then
                echo "ðŸŒ ${console_base}/k8s/ns/$namespace/pods/$pod_name/terminal" >&2
            fi
        fi
        return
    fi
    
    # Handle 'logs' command - link to pod logs
    if [[ "$cmd" == "logs" ]]; then
        local console_base=$(get_console_url)
        if [[ -n "$console_base" ]]; then
            local pod_name=""
            local namespace=""
            
            # Parse logs command arguments to find pod name and namespace
            local i=0
            while [[ $i -lt ${#args[@]} ]]; do
                case "${args[$i]}" in
                    -n|--namespace)
                        i=$((i + 1))
                        if [[ $i -lt ${#args[@]} ]]; then
                            namespace="${args[$i]}"
                        fi
                        ;;
                    -c|--container|-f|--follow|--tail|--since|--since-time|--timestamps|--prefix)
                        # Skip these flags and their values (except boolean flags)
                        if [[ "${args[$i]}" == "-c" || "${args[$i]}" == "--container" || "${args[$i]}" == "--tail" || "${args[$i]}" == "--since" || "${args[$i]}" == "--since-time" ]]; then
                            i=$((i + 1))
                        fi
                        ;;
                    -*)
                        # Skip other flags
                        ;;
                    *)
                        # Handle resource/name format (e.g., pod/nginx or deployment/myapp)
                        if [[ "${args[$i]}" == *"/"* ]]; then
                            local resource_type="${args[$i]%%/*}"
                            pod_name="${args[$i]#*/}"
                            # For non-pod resources, we'll still try to link to logs but it might not work perfectly
                        else
                            # First non-flag argument should be the pod name
                            if [[ -z "$pod_name" ]]; then
                                pod_name="${args[$i]}"
                            fi
                        fi
                        ;;
                esac
                i=$((i + 1))
            done
            
            # If no namespace specified, get current namespace from context
            if [[ -z "$namespace" ]]; then
                namespace=$(get_current_namespace)
            fi
            
            # Generate logs URL if we have pod name and namespace
            if [[ -n "$pod_name" && -n "$namespace" ]]; then
                echo "ðŸŒ ${console_base}/k8s/ns/$namespace/pods/$pod_name/logs" >&2
            fi
        fi
        return
    fi
    
    # Handle 'run' command - link to pod creation form
    if [[ "$cmd" == "run" ]]; then
        local console_base=$(get_console_url)
        if [[ -n "$console_base" ]]; then
            local namespace=""
            
            # Parse run command arguments to find namespace
            local i=0
            while [[ $i -lt ${#args[@]} ]]; do
                case "${args[$i]}" in
                    -n|--namespace)
                        i=$((i + 1))
                        if [[ $i -lt ${#args[@]} ]]; then
                            namespace="${args[$i]}"
                        fi
                        ;;
                esac
                i=$((i + 1))
            done
            
            # If no namespace specified, get current namespace from context
            if [[ -z "$namespace" ]]; then
                namespace=$(get_current_namespace)
            fi
            
            if [[ -n "$namespace" ]]; then
                echo "ðŸŒ ${console_base}/k8s/ns/$namespace/pods/~new" >&2
            fi
        fi
        return
    fi
    
    # Handle 'create' command - link to appropriate creation forms
    if [[ "$cmd" == "create" ]]; then
        local console_base=$(get_console_url)
        if [[ -n "$console_base" ]]; then
            local resource_type=""
            local secret_type=""
            local namespace=""
            
            # Parse create command arguments
            local i=0
            while [[ $i -lt ${#args[@]} ]]; do
                case "${args[$i]}" in
                    -n|--namespace)
                        i=$((i + 1))
                        if [[ $i -lt ${#args[@]} ]]; then
                            namespace="${args[$i]}"
                        fi
                        ;;
                    # Resources available through 'oc create' command
                    build)
                        resource_type="build"
                        ;;
                    clusterresourcequota)
                        resource_type="clusterresourcequota"
                        ;;
                    clusterrole|clusterroles)
                        resource_type="clusterrole"
                        ;;
                    clusterrolebinding|clusterrolebindings)
                        resource_type="clusterrolebinding"
                        ;;
                    configmap|configmaps)
                        resource_type="configmap"
                        ;;
                    cronjob|cronjobs)
                        resource_type="cronjob"
                        ;;
                    deployment|deployments)
                        resource_type="deployment"
                        ;;
                    deploymentconfig|deploymentconfigs)
                        resource_type="deploymentconfig"
                        ;;
                    identity|identities)
                        resource_type="identity"
                        ;;
                    imagestream|imagestreams)
                        resource_type="imagestream"
                        ;;
                    imagestreamtag|imagestreamtags)
                        resource_type="imagestreamtag"
                        ;;
                    ingress|ingresses)
                        resource_type="ingress"
                        ;;
                    job|jobs)
                        resource_type="job"
                        ;;
                    namespace|namespaces)
                        resource_type="namespace"
                        ;;
                    poddisruptionbudget|poddisruptionbudgets|pdb)
                        resource_type="poddisruptionbudget"
                        ;;
                    priorityclass|priorityclasses)
                        resource_type="priorityclass"
                        ;;
                    quota|resourcequota|resourcequotas)
                        resource_type="resourcequota"
                        ;;
                    role|roles)
                        resource_type="role"
                        ;;
                    rolebinding|rolebindings)
                        resource_type="rolebinding"
                        ;;
                    route|routes)
                        resource_type="route"
                        ;;
                    secret|secrets)
                        resource_type="secret"
                        # Check for secret type
                        if [[ $((i + 1)) -lt ${#args[@]} ]]; then
                            case "${args[$((i + 1))]}" in
                                generic)
                                    secret_type="generic"
                                    ;;
                                docker-registry)
                                    secret_type="docker-registry"
                                    ;;
                                tls)
                                    secret_type="tls"
                                    ;;
                            esac
                        fi
                        ;;
                    service|services)
                        resource_type="service"
                        ;;
                    serviceaccount|serviceaccounts)
                        resource_type="serviceaccount"
                        ;;
                    token)
                        resource_type="token"
                        ;;
                    user|users)
                        resource_type="user"
                        ;;
                    useridentitymapping|useridentitymappings)
                        resource_type="useridentitymapping"
                        ;;
                esac
                i=$((i + 1))
            done
            
            # If no namespace specified, get current namespace from context
            if [[ -z "$namespace" ]]; then
                namespace=$(get_current_namespace)
            fi
            
            # Generate appropriate console URL based on resource type
            if [[ -n "$resource_type" ]]; then
                case "$resource_type" in
                    # Cluster-scoped resources
                    clusterresourcequota)
                        echo "ðŸŒ ${console_base}/k8s/cluster/quota.openshift.io~v1~ClusterResourceQuota/~new" >&2
                        ;;
                    clusterrole)
                        echo "ðŸŒ ${console_base}/k8s/cluster/rbac.authorization.k8s.io~v1~ClusterRole/~new" >&2
                        ;;
                    clusterrolebinding)
                        echo "ðŸŒ ${console_base}/k8s/cluster/rbac.authorization.k8s.io~v1~ClusterRoleBinding/~new" >&2
                        ;;
                    namespace)
                        echo "ðŸŒ ${console_base}/k8s/cluster/core~v1~Namespace/~new" >&2
                        ;;
                    priorityclass)
                        echo "ðŸŒ ${console_base}/k8s/cluster/scheduling.k8s.io~v1~PriorityClass/~new" >&2
                        ;;
                    user)
                        echo "ðŸŒ ${console_base}/k8s/cluster/user.openshift.io~v1~User/~new" >&2
                        ;;
                    identity)
                        echo "ðŸŒ ${console_base}/k8s/cluster/user.openshift.io~v1~Identity/~new" >&2
                        ;;
                    useridentitymapping)
                        echo "ðŸŒ ${console_base}/k8s/cluster/user.openshift.io~v1~UserIdentityMapping/~new" >&2
                        ;;
                    # Namespaced resources
                    *)
                        if [[ -n "$namespace" ]]; then
                            case "$resource_type" in
                                build)
                                    echo "ðŸŒ ${console_base}/k8s/ns/$namespace/build.openshift.io~v1~Build/~new" >&2
                                    ;;
                                configmap)
                                    echo "ðŸŒ ${console_base}/k8s/ns/$namespace/configmaps/~new" >&2
                                    ;;
                                cronjob)
                                    echo "ðŸŒ ${console_base}/k8s/ns/$namespace/cronjobs/~new" >&2
                                    ;;
                                deployment)
                                    echo "ðŸŒ ${console_base}/k8s/ns/$namespace/deployments/~new/form" >&2
                                    ;;
                                deploymentconfig)
                                    echo "ðŸŒ ${console_base}/k8s/ns/$namespace/apps.openshift.io~v1~DeploymentConfig/~new" >&2
                                    ;;
                                imagestream)
                                    echo "ðŸŒ ${console_base}/k8s/ns/$namespace/image.openshift.io~v1~ImageStream/~new" >&2
                                    ;;
                                imagestreamtag)
                                    echo "ðŸŒ ${console_base}/k8s/ns/$namespace/image.openshift.io~v1~ImageStreamTag/~new" >&2
                                    ;;
                                ingress)
                                    echo "ðŸŒ ${console_base}/k8s/ns/$namespace/ingresses/~new" >&2
                                    ;;
                                job)
                                    echo "ðŸŒ ${console_base}/k8s/ns/$namespace/jobs/~new" >&2
                                    ;;
                                poddisruptionbudget)
                                    echo "ðŸŒ ${console_base}/k8s/ns/$namespace/poddisruptionbudgets/~new" >&2
                                    ;;
                                resourcequota)
                                    echo "ðŸŒ ${console_base}/k8s/ns/$namespace/resourcequotas/~new" >&2
                                    ;;
                                role)
                                    echo "ðŸŒ ${console_base}/k8s/ns/$namespace/roles/~new" >&2
                                    ;;
                                rolebinding)
                                    echo "ðŸŒ ${console_base}/k8s/ns/$namespace/rolebindings/~new" >&2
                                    ;;
                                route)
                                    echo "ðŸŒ ${console_base}/k8s/ns/$namespace/route.openshift.io~v1~Route/~new" >&2
                                    ;;
                                secret)
                                    case "$secret_type" in
                                        generic)
                                            echo "ðŸŒ ${console_base}/k8s/ns/$namespace/secrets/~new/generic" >&2
                                            ;;
                                        docker-registry)
                                            echo "ðŸŒ ${console_base}/k8s/ns/$namespace/secrets/~new/image" >&2
                                            ;;
                                        tls)
                                            echo "ðŸŒ ${console_base}/k8s/ns/$namespace/secrets/~new/tls" >&2
                                            ;;
                                        *)
                                            echo "ðŸŒ ${console_base}/k8s/ns/$namespace/secrets/~new" >&2
                                            ;;
                                    esac
                                    ;;
                                service)
                                    echo "ðŸŒ ${console_base}/k8s/ns/$namespace/services/~new" >&2
                                    ;;
                                serviceaccount)
                                    echo "ðŸŒ ${console_base}/k8s/ns/$namespace/serviceaccounts/~new" >&2
                                    ;;
                                token)
                                    # Token creation doesn't have a specific form, link to service accounts
                                    echo "ðŸŒ ${console_base}/k8s/ns/$namespace/serviceaccounts" >&2
                                    ;;
                            esac
                        fi
                        ;;
                esac
            fi
        fi
        return
    fi
    
    # Handle 'explain' command - link to OpenShift console API resource schema
    if [[ "$cmd" == "explain" ]]; then
        if [[ -n "${args[0]}" ]]; then
            local resource_field="${args[0]}"
            # Extract base resource type (e.g., deployment from deployment.spec.replicas)
            local base_resource="${resource_field%%.*}"
            local console_base=$(get_console_url)
            
            if [[ -n "$console_base" ]]; then
                # Get the API group, version, and kind directly from oc explain
                local explain_output=$(oc explain "$base_resource" 2>/dev/null | head -10)
                local group=$(echo "$explain_output" | grep "^GROUP:" | awk '{print $2}')
                local kind=$(echo "$explain_output" | grep "^KIND:" | awk '{print $2}')
                local version=$(echo "$explain_output" | grep "^VERSION:" | awk '{print $2}')
                
                local converted_type=""
                if [[ -n "$group" && -n "$version" && -n "$kind" ]]; then
                    # Convert to console format: group~version~Kind
                    converted_type="${group}~${version}~${kind}"
                elif [[ -n "$kind" && -n "$version" ]]; then
                    # Core resources don't have a group, use "core"
                    converted_type="core~${version}~${kind}"
                else
                    # Fallback to the conversion function
                    converted_type=$(convert_resource_to_console_format "$base_resource")
                fi
                
                # Determine if resource is namespaced to choose correct URL path
                local namespace_path=""
                if is_resource_namespaced "$base_resource"; then
                    # Namespaced resource - use current namespace
                    local current_namespace=$(get_current_namespace)
                    if [[ -n "$current_namespace" ]]; then
                        namespace_path="ns/$current_namespace"
                    else
                        namespace_path="all-namespaces"
                    fi
                else
                    # Cluster-scoped resource - use all-namespaces
                    namespace_path="all-namespaces"
                fi
                
                echo "ðŸŒ ${console_base}/api-resource/$namespace_path/$converted_type/schema" >&2
            fi
        fi
        return
    fi
    
    # Only generate URLs for 'get' and 'describe' commands
    if [[ "$cmd" != "get" && "$cmd" != "describe" ]]; then
        return
    fi
    
    # Get console base URL
    local console_base=$(get_console_url)
    if [[ -z "$console_base" ]]; then
        return
    fi
    
    local resource_type=""
    local namespace=""
    local resource_name=""
    local label_selector=""
    
    # Parse arguments
    local i=0
    while [[ $i -lt ${#args[@]} ]]; do
        case "${args[$i]}" in
            -n|--namespace)
                i=$((i + 1))
                if [[ $i -lt ${#args[@]} ]]; then
                    namespace="${args[$i]}"
                fi
                ;;
            -l|--selector)
                i=$((i + 1))
                if [[ $i -lt ${#args[@]} ]]; then
                    label_selector="${args[$i]}"
                fi
                ;;
            -o|--output|-w|--watch|--watch-only|--field-selector|--sort-by|--chunk-size)
                # Skip these flags and their values
                i=$((i + 1))
                ;;
            --no-headers|--show-labels|--show-kind|--ignore-not-found|-A|--all-namespaces)
                # Skip boolean flags
                ;;
            -*)
                # Skip other flags
                ;;
            *)
                if [[ -z "$resource_type" ]]; then
                    # Handle resource_type/resource_name format (e.g., pod/my-pod)
                    if [[ "${args[$i]}" == *"/"* ]]; then
                        resource_type="${args[$i]%%/*}"
                        resource_name="${args[$i]#*/}"
                    else
                        resource_type="${args[$i]}"
                    fi
                elif [[ -z "$resource_name" ]]; then
                    resource_name="${args[$i]}"
                fi
                ;;
        esac
        i=$((i + 1))
    done
    
    # If no namespace specified, get current namespace from context
    if [[ -z "$namespace" ]]; then
        namespace=$(get_current_namespace)
    fi
    
    # Generate appropriate console path
    local console_path=""
    
    # Normalize resource type (remove API group suffix and convert to lowercase)
    local normalized_type=$(echo "$resource_type" | sed 's/\.[a-zA-Z0-9.-]*$//' | tr '[:upper:]' '[:lower:]')
    
    # Check if resource type is cluster-wide
    case "$normalized_type" in
        # Cluster-scoped resources
        nodes|node|no)
            if [[ -n "$resource_name" ]]; then
                console_path="/k8s/cluster/core~v1~Node/$resource_name"
            else
                console_path="/k8s/cluster/core~v1~Node"
            fi
            ;;
        namespaces|namespace|ns)
            if [[ -n "$resource_name" ]]; then
                console_path="/k8s/cluster/core~v1~Namespace/$resource_name"
            else
                console_path="/k8s/cluster/core~v1~Namespace"
            fi
            ;;
        persistentvolumes|persistentvolume|pv)
            if [[ -n "$resource_name" ]]; then
                console_path="/k8s/cluster/core~v1~PersistentVolume/$resource_name"
            else
                console_path="/k8s/cluster/core~v1~PersistentVolume"
            fi
            ;;
        clusterroles|clusterrole)
            if [[ -n "$resource_name" ]]; then
                console_path="/k8s/cluster/rbac.authorization.k8s.io~v1~ClusterRole/$resource_name"
            else
                console_path="/k8s/cluster/rbac.authorization.k8s.io~v1~ClusterRole"
            fi
            ;;
        clusterrolebindings|clusterrolebinding)
            if [[ -n "$resource_name" ]]; then
                console_path="/k8s/cluster/rbac.authorization.k8s.io~v1~ClusterRoleBinding/$resource_name"
            else
                console_path="/k8s/cluster/rbac.authorization.k8s.io~v1~ClusterRoleBinding"
            fi
            ;;
        storageclasses|storageclass|sc)
            if [[ -n "$resource_name" ]]; then
                console_path="/k8s/cluster/storage.k8s.io~v1~StorageClass/$resource_name"
            else
                console_path="/k8s/cluster/storage.k8s.io~v1~StorageClass"
            fi
            ;;
        ingressclasses|ingressclass)
            if [[ -n "$resource_name" ]]; then
                console_path="/k8s/cluster/networking.k8s.io~v1~IngressClass/$resource_name"
            else
                console_path="/k8s/cluster/networking.k8s.io~v1~IngressClass"
            fi
            ;;
        volumesnapshotclasses|volumesnapshotclass)
            if [[ -n "$resource_name" ]]; then
                console_path="/k8s/cluster/snapshot.storage.k8s.io~v1~VolumeSnapshotClass/$resource_name"
            else
                console_path="/k8s/cluster/snapshot.storage.k8s.io~v1~VolumeSnapshotClass"
            fi
            ;;
        volumesnapshotcontents|volumesnapshotcontent)
            if [[ -n "$resource_name" ]]; then
                console_path="/k8s/cluster/snapshot.storage.k8s.io~v1~VolumeSnapshotContent/$resource_name"
            else
                console_path="/k8s/cluster/snapshot.storage.k8s.io~v1~VolumeSnapshotContent"
            fi
            ;;
        machines|machine)
            if [[ -n "$resource_name" ]]; then
                console_path="/k8s/ns/openshift-machine-api/machine.openshift.io~v1beta1~Machine/$resource_name"
            else
                console_path="/k8s/ns/openshift-machine-api/machine.openshift.io~v1beta1~Machine"
            fi
            ;;
        machinesets|machineset)
            if [[ -n "$resource_name" ]]; then
                console_path="/k8s/ns/openshift-machine-api/machine.openshift.io~v1beta1~MachineSet/$resource_name"
            else
                console_path="/k8s/ns/openshift-machine-api/machine.openshift.io~v1beta1~MachineSet"
            fi
            ;;
        machineautoscalers|machineautoscaler)
            if [[ -n "$resource_name" ]]; then
                console_path="/k8s/ns/openshift-machine-api/autoscaling.openshift.io~v1beta1~MachineAutoscaler/$resource_name"
            else
                console_path="/k8s/ns/openshift-machine-api/autoscaling.openshift.io~v1beta1~MachineAutoscaler"
            fi
            ;;
        machinehealthchecks|machinehealthcheck)
            if [[ -n "$resource_name" ]]; then
                console_path="/k8s/ns/openshift-machine-api/machine.openshift.io~v1beta1~MachineHealthCheck/$resource_name"
            else
                console_path="/k8s/ns/openshift-machine-api/machine.openshift.io~v1beta1~MachineHealthCheck"
            fi
            ;;
        machineconfigs|machineconfig)
            if [[ -n "$resource_name" ]]; then
                console_path="/k8s/cluster/machineconfiguration.openshift.io~v1~MachineConfig/$resource_name"
            else
                console_path="/k8s/cluster/machineconfiguration.openshift.io~v1~MachineConfig"
            fi
            ;;
        machineconfigpools|machineconfigpool)
            if [[ -n "$resource_name" ]]; then
                console_path="/k8s/cluster/machineconfiguration.openshift.io~v1~MachineConfigPool/$resource_name"
            else
                console_path="/k8s/cluster/machineconfiguration.openshift.io~v1~MachineConfigPool"
            fi
            ;;
        users|user)
            if [[ -n "$resource_name" ]]; then
                console_path="/k8s/cluster/user.openshift.io~v1~User/$resource_name"
            else
                console_path="/k8s/cluster/user.openshift.io~v1~User"
            fi
            ;;
        groups|group)
            if [[ -n "$resource_name" ]]; then
                console_path="/k8s/cluster/user.openshift.io~v1~Group/$resource_name"
            else
                console_path="/k8s/cluster/user.openshift.io~v1~Group"
            fi
            ;;
        customresourcedefinitions|customresourcedefinition|crd|crds)
            if [[ -n "$resource_name" ]]; then
                console_path="/k8s/cluster/apiextensions.k8s.io~v1~CustomResourceDefinition/$resource_name"
            else
                console_path="/k8s/cluster/apiextensions.k8s.io~v1~CustomResourceDefinition"
            fi
            ;;
        projects|project)
            if [[ -n "$resource_name" ]]; then
                console_path="/k8s/cluster/project.openshift.io~v1~Project/$resource_name"
            else
                console_path="/k8s/cluster/project.openshift.io~v1~Project"
            fi
            ;;
        # Special monitoring resources that should go to monitoring pages
        servicemonitors|servicemonitor)
            console_path="/monitoring/targets"
            ;;
        prometheusrules|prometheusrule)
            console_path="/monitoring/query-browser"
            ;;
        alertmanagers|alertmanager)
            console_path="/monitoring/alerts"
            ;;
        alertingrules|alertingrule)
            console_path="/monitoring/alertrules"
            ;;
        # Special cases for overview pages
        alerts)
            console_path="/monitoring/alerts"
            ;;
        *)
            # Namespaced resources
            if [[ -n "$namespace" ]]; then
                case "$normalized_type" in
                    pods|pod|po)
                        if [[ -n "$resource_name" ]]; then
                            console_path="/k8s/ns/$namespace/core~v1~Pod/$resource_name"
                        else
                            console_path="/k8s/ns/$namespace/core~v1~Pod"
                        fi
                        ;;
                    deployments|deployment|deploy)
                        if [[ -n "$resource_name" ]]; then
                            console_path="/k8s/ns/$namespace/apps~v1~Deployment/$resource_name"
                        else
                            console_path="/k8s/ns/$namespace/apps~v1~Deployment"
                        fi
                        ;;
                    deploymentconfigs|deploymentconfig|dc)
                        if [[ -n "$resource_name" ]]; then
                            console_path="/k8s/ns/$namespace/apps.openshift.io~v1~DeploymentConfig/$resource_name"
                        else
                            console_path="/k8s/ns/$namespace/apps.openshift.io~v1~DeploymentConfig"
                        fi
                        ;;
                    statefulsets|statefulset|sts)
                        if [[ -n "$resource_name" ]]; then
                            console_path="/k8s/ns/$namespace/apps~v1~StatefulSet/$resource_name"
                        else
                            console_path="/k8s/ns/$namespace/apps~v1~StatefulSet"
                        fi
                        ;;
                    secrets|secret)
                        if [[ -n "$resource_name" ]]; then
                            console_path="/k8s/ns/$namespace/core~v1~Secret/$resource_name"
                        else
                            console_path="/k8s/ns/$namespace/core~v1~Secret"
                        fi
                        ;;
                    configmaps|configmap|cm)
                        if [[ -n "$resource_name" ]]; then
                            console_path="/k8s/ns/$namespace/core~v1~ConfigMap/$resource_name"
                        else
                            console_path="/k8s/ns/$namespace/core~v1~ConfigMap"
                        fi
                        ;;
                    cronjobs|cronjob|cj)
                        if [[ -n "$resource_name" ]]; then
                            console_path="/k8s/ns/$namespace/batch~v1~CronJob/$resource_name"
                        else
                            console_path="/k8s/ns/$namespace/batch~v1~CronJob"
                        fi
                        ;;
                    jobs|job)
                        if [[ -n "$resource_name" ]]; then
                            console_path="/k8s/ns/$namespace/batch~v1~Job/$resource_name"
                        else
                            console_path="/k8s/ns/$namespace/batch~v1~Job"
                        fi
                        ;;
                    daemonsets|daemonset|ds)
                        if [[ -n "$resource_name" ]]; then
                            console_path="/k8s/ns/$namespace/apps~v1~DaemonSet/$resource_name"
                        else
                            console_path="/k8s/ns/$namespace/apps~v1~DaemonSet"
                        fi
                        ;;
                    replicasets|replicaset|rs)
                        if [[ -n "$resource_name" ]]; then
                            console_path="/k8s/ns/$namespace/apps~v1~ReplicaSet/$resource_name"
                        else
                            console_path="/k8s/ns/$namespace/apps~v1~ReplicaSet"
                        fi
                        ;;
                    replicationcontrollers|replicationcontroller|rc)
                        if [[ -n "$resource_name" ]]; then
                            console_path="/k8s/ns/$namespace/core~v1~ReplicationController/$resource_name"
                        else
                            console_path="/k8s/ns/$namespace/core~v1~ReplicationController"
                        fi
                        ;;
                    horizontalpodautoscalers|horizontalpodautoscaler|hpa)
                        if [[ -n "$resource_name" ]]; then
                            console_path="/k8s/ns/$namespace/autoscaling~v2~HorizontalPodAutoscaler/$resource_name"
                        else
                            console_path="/k8s/ns/$namespace/autoscaling~v2~HorizontalPodAutoscaler"
                        fi
                        ;;
                    poddisruptionbudgets|poddisruptionbudget|pdb)
                        if [[ -n "$resource_name" ]]; then
                            console_path="/k8s/ns/$namespace/policy~v1~PodDisruptionBudget/$resource_name"
                        else
                            console_path="/k8s/ns/$namespace/policy~v1~PodDisruptionBudget"
                        fi
                        ;;
                    services|service|svc)
                        if [[ -n "$resource_name" ]]; then
                            console_path="/k8s/ns/$namespace/core~v1~Service/$resource_name"
                        else
                            console_path="/k8s/ns/$namespace/core~v1~Service"
                        fi
                        ;;
                    routes|route)
                        if [[ -n "$resource_name" ]]; then
                            console_path="/k8s/ns/$namespace/route.openshift.io~v1~Route/$resource_name"
                        else
                            console_path="/k8s/ns/$namespace/route.openshift.io~v1~Route"
                        fi
                        ;;
                    ingresses|ingress|ing)
                        if [[ -n "$resource_name" ]]; then
                            console_path="/k8s/ns/$namespace/networking.k8s.io~v1~Ingress/$resource_name"
                        else
                            console_path="/k8s/ns/$namespace/networking.k8s.io~v1~Ingress"
                        fi
                        ;;
                    networkpolicies|networkpolicy|netpol)
                        if [[ -n "$resource_name" ]]; then
                            console_path="/k8s/ns/$namespace/networking.k8s.io~v1~NetworkPolicy/$resource_name"
                        else
                            console_path="/k8s/ns/$namespace/networking.k8s.io~v1~NetworkPolicy"
                        fi
                        ;;
                    userdefinednetworks|userdefinednetwork)
                        if [[ -n "$resource_name" ]]; then
                            console_path="/k8s/ns/$namespace/k8s.ovn.org~v1~UserDefinedNetwork/$resource_name"
                        else
                            console_path="/k8s/ns/$namespace/k8s.ovn.org~v1~UserDefinedNetwork"
                        fi
                        ;;
                    persistentvolumeclaims|persistentvolumeclaim|pvc)
                        if [[ -n "$resource_name" ]]; then
                            console_path="/k8s/ns/$namespace/core~v1~PersistentVolumeClaim/$resource_name"
                        else
                            console_path="/k8s/ns/$namespace/core~v1~PersistentVolumeClaim"
                        fi
                        ;;
                    volumesnapshots|volumesnapshot)
                        if [[ -n "$resource_name" ]]; then
                            console_path="/k8s/ns/$namespace/snapshot.storage.k8s.io~v1~VolumeSnapshot/$resource_name"
                        else
                            console_path="/k8s/ns/$namespace/snapshot.storage.k8s.io~v1~VolumeSnapshot"
                        fi
                        ;;
                    buildconfigs|buildconfig|bc)
                        if [[ -n "$resource_name" ]]; then
                            console_path="/k8s/ns/$namespace/build.openshift.io~v1~BuildConfig/$resource_name"
                        else
                            console_path="/k8s/ns/$namespace/build.openshift.io~v1~BuildConfig"
                        fi
                        ;;
                    builds|build)
                        if [[ -n "$resource_name" ]]; then
                            console_path="/k8s/ns/$namespace/build.openshift.io~v1~Build/$resource_name"
                        else
                            console_path="/k8s/ns/$namespace/build.openshift.io~v1~Build"
                        fi
                        ;;
                    imagestreams|imagestream|is)
                        if [[ -n "$resource_name" ]]; then
                            console_path="/k8s/ns/$namespace/image.openshift.io~v1~ImageStream/$resource_name"
                        else
                            console_path="/k8s/ns/$namespace/image.openshift.io~v1~ImageStream"
                        fi
                        ;;
                    serviceaccounts|serviceaccount|sa)
                        if [[ -n "$resource_name" ]]; then
                            console_path="/k8s/ns/$namespace/core~v1~ServiceAccount/$resource_name"
                        else
                            console_path="/k8s/ns/$namespace/core~v1~ServiceAccount"
                        fi
                        ;;
                    roles|role)
                        if [[ -n "$resource_name" ]]; then
                            console_path="/k8s/ns/$namespace/rbac.authorization.k8s.io~v1~Role/$resource_name"
                        else
                            console_path="/k8s/ns/$namespace/rbac.authorization.k8s.io~v1~Role"
                        fi
                        ;;
                    rolebindings|rolebinding)
                        if [[ -n "$resource_name" ]]; then
                            console_path="/k8s/ns/$namespace/rbac.authorization.k8s.io~v1~RoleBinding/$resource_name"
                        else
                            console_path="/k8s/ns/$namespace/rbac.authorization.k8s.io~v1~RoleBinding"
                        fi
                        ;;
                    resourcequotas|resourcequota|quota)
                        if [[ -n "$resource_name" ]]; then
                            console_path="/k8s/ns/$namespace/core~v1~ResourceQuota/$resource_name"
                        else
                            console_path="/k8s/ns/$namespace/core~v1~ResourceQuota"
                        fi
                        ;;
                    limitranges|limitrange|limits)
                        if [[ -n "$resource_name" ]]; then
                            console_path="/k8s/ns/$namespace/core~v1~LimitRange/$resource_name"
                        else
                            console_path="/k8s/ns/$namespace/core~v1~LimitRange"
                        fi
                        ;;
                    clusterserviceversions|clusterserviceversion|csv)
                        if [[ -n "$resource_name" ]]; then
                            console_path="/k8s/ns/$namespace/operators.coreos.com~v1alpha1~ClusterServiceVersion/$resource_name"
                        else
                            console_path="/k8s/ns/$namespace/operators.coreos.com~v1alpha1~ClusterServiceVersion"
                        fi
                        ;;
                    events|event|ev)
                        console_path="/k8s/ns/$namespace/events"
                        ;;
                    *)
                        # For unknown resources, determine if they are namespaced and use appropriate URL path
                        # Try to get API info from oc explain first, then fall back to convert function
                        local explain_output=$(oc explain "$resource_type" 2>/dev/null | head -10)
                        local group=$(echo "$explain_output" | grep "^GROUP:" | awk '{print $2}')
                        local kind=$(echo "$explain_output" | grep "^KIND:" | awk '{print $2}')
                        local version=$(echo "$explain_output" | grep "^VERSION:" | awk '{print $2}')
                        
                        local converted_type=""
                        if [[ -n "$group" && -n "$version" && -n "$kind" ]]; then
                            # Convert to console format: group~version~Kind
                            converted_type="${group}~${version}~${kind}"
                        elif [[ -n "$kind" && -n "$version" ]]; then
                            # Core resources don't have a group, use "core"
                            converted_type="core~${version}~${kind}"
                        else
                            # Fallback to the conversion function
                            converted_type=$(convert_resource_to_console_format "$resource_type")
                        fi
                        
                        # Determine if resource is namespaced to choose correct URL path
                        local namespace_path=""
                        if is_resource_namespaced "$resource_type"; then
                            # Namespaced resource - use current namespace
                            if [[ -n "$namespace" ]]; then
                                namespace_path="ns/$namespace"
                            else
                                namespace_path="all-namespaces"
                            fi
                        else
                            # Cluster-scoped resource - use all-namespaces
                            namespace_path="all-namespaces"
                        fi
                        
                        if [[ -n "$resource_name" ]]; then
                            # For specific resource instances, use the standard k8s path format
                            if [[ -n "$namespace" ]]; then
                                console_path="/k8s/ns/$namespace/$converted_type/$resource_name"
                            else
                                console_path="/k8s/cluster/$converted_type/$resource_name"
                            fi
                        else
                            console_path="/api-resource/$namespace_path/$converted_type/instances"
                        fi
                        ;;
                esac
            else
                # For unknown resources without namespace context, determine if they are namespaced
                # Try to get API info from oc explain first, then fall back to convert function
                local explain_output=$(oc explain "$resource_type" 2>/dev/null | head -10)
                local group=$(echo "$explain_output" | grep "^GROUP:" | awk '{print $2}')
                local kind=$(echo "$explain_output" | grep "^KIND:" | awk '{print $2}')
                local version=$(echo "$explain_output" | grep "^VERSION:" | awk '{print $2}')
                
                local converted_type=""
                if [[ -n "$group" && -n "$version" && -n "$kind" ]]; then
                    # Convert to console format: group~version~Kind
                    converted_type="${group}~${version}~${kind}"
                elif [[ -n "$kind" && -n "$version" ]]; then
                    # Core resources don't have a group, use "core"
                    converted_type="core~${version}~${kind}"
                else
                    # Fallback to the conversion function
                    converted_type=$(convert_resource_to_console_format "$resource_type")
                fi
                
                # Determine if resource is namespaced to choose correct URL path
                local namespace_path=""
                if is_resource_namespaced "$resource_type"; then
                    # Namespaced resource - but no namespace context, so use all-namespaces
                    namespace_path="all-namespaces"
                else
                    # Cluster-scoped resource - use all-namespaces
                    namespace_path="all-namespaces"
                fi
                
                if [[ -n "$resource_name" ]]; then
                    # For specific resource instances, use the standard k8s path format
                    if is_resource_namespaced "$resource_type"; then
                        console_path="/k8s/all-namespaces/$converted_type/$resource_name"
                    else
                        console_path="/k8s/cluster/$converted_type/$resource_name"
                    fi
                else
                    console_path="/api-resource/$namespace_path/$converted_type/instances"
                fi
            fi
            ;;
    esac
    
    # Generate and output URL to stderr if we have a path
    if [[ -n "$console_path" ]]; then
        local final_url="${console_base}${console_path}"
        
        # Add query parameters if we have a label selector
        if [[ -n "$label_selector" ]]; then
            # URL encode the label selector
            local encoded_selector=$(printf '%s' "$label_selector" | sed 's/=/=%3D/g; s/,/%2C/g; s/ /%20/g')
            final_url="${final_url}?labels=${encoded_selector}"
        fi
        
        echo "ðŸŒ ${final_url}" >&2
    fi
}

# Check if we can get console URL (only show URLs if we can connect to OpenShift)
CONSOLE_BASE=$(get_console_url)
if [[ -n "$CONSOLE_BASE" ]]; then
    SHOW_URLS=true
else
    SHOW_URLS=false
fi

# Execute the original oc command and capture its exit code
if [[ $SHOW_URLS == true ]]; then
    # Generate console URL before executing command (to stderr)
    generate_console_url "$@"
fi

# Execute the original oc command, preserving all arguments and behavior
exec oc "$@"
